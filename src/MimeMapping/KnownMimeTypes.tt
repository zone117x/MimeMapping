<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Net.Http" #>
<#@ assembly name="System.Text.Json" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Text.Json" #>
<#@ output extension="cs" #>
using System;

namespace MimeMapping
{
<#
    const string MIMEDB_URL = "https://raw.githubusercontent.com/jshttp/mime-db/v1.54.0/db.json";
#>
    ///<summary>
    /// MIME type constants. Last updated on <#= DateTime.UtcNow.ToString("s") + "Z" #>. 
    /// Generated from the <a href="<#= MIMEDB_URL #>">mime-db</a> source
    ///</summary>
    public static class KnownMimeTypes
    {

<#
        Regex rgx = new Regex("[^a-zA-Z0-9]");

        string GetMimeFieldName(string mimeKey)
        {
            var result = rgx.Replace(mimeKey[0].ToString().ToUpperInvariant() + mimeKey.Substring(1), "");
            return char.IsDigit(result[0]) ? ("_" + result) : result;
        }

        string GetPageContent(string url)
        {
            using var client = new HttpClient();
            return client.GetStringAsync(url).GetAwaiter().GetResult();
        }

        // Get priority for source (higher is better)
        // iana=3, apache=2, nginx=1, other=0
        Func<string, int> GetSourcePriority = (source) =>
        {
            if (source == "iana") return 3;
            if (source == "apache") return 2;
            if (source == "nginx") return 1;
            return 0;
        };

        // Get priority for mime type category (higher is better)
        // Prefer specific types (video/*, audio/*, image/*, text/*) over application/*
        Func<string, int> GetTypePriority = (mimeType) =>
        {
            if (mimeType.StartsWith("video/")) return 4;
            if (mimeType.StartsWith("audio/")) return 4;
            if (mimeType.StartsWith("image/")) return 4;
            if (mimeType.StartsWith("text/")) return 3;
            if (mimeType.StartsWith("font/")) return 3;
            if (mimeType.StartsWith("model/")) return 2;
            if (mimeType.StartsWith("application/")) return 1;
            return 0;
        };

        // Returns list of (mimeType, extension, source)
        Func<string, List<Tuple<string, string, string>>> GetMimeTypesFromJson = (url) =>
        {
            var content = GetPageContent(url);
            if (string.IsNullOrEmpty(content)) return new List<Tuple<string, string, string>>();

            using var doc = JsonDocument.Parse(content);
            var results = new List<Tuple<string, string, string>>();

            foreach (var mimeTypeEntry in doc.RootElement.EnumerateObject())
            {
                var mimeType = mimeTypeEntry.Name;
                var source = mimeTypeEntry.Value.TryGetProperty("source", out var sourceEl)
                    ? sourceEl.GetString()
                    : null;

                if (mimeTypeEntry.Value.TryGetProperty("extensions", out var extensions))
                {
                    foreach (var ext in extensions.EnumerateArray())
                    {
                        results.Add(Tuple.Create(mimeType, ext.GetString(), source));
                    }
                }
            }

            return results;
        };

        var entries = GetMimeTypesFromJson(MIMEDB_URL);

        // build dictionary from entries with conflict resolution
        // _entryDict stores (mimeType, source) for each extension
        var _dict = new Dictionary<string, string>();
        var _entryDict = new Dictionary<string, Tuple<string, string>>();
        var _reverseDict = new Dictionary<string, List<string>>();

        foreach (var entry in entries)
        {
            var mimeType = entry.Item1;
            var ext = entry.Item2;
            var source = entry.Item3;

            if (_entryDict.TryGetValue(ext, out var existing))
            {
                if (existing.Item1 != mimeType)
                {
                    // Compare priorities to decide which one wins
                    var existingSourcePri = GetSourcePriority(existing.Item2);
                    var newSourcePri = GetSourcePriority(source);
                    var existingTypePri = GetTypePriority(existing.Item1);
                    var newTypePri = GetTypePriority(mimeType);

                    var shouldReplace = newSourcePri > existingSourcePri ||
                        (newSourcePri == existingSourcePri && newTypePri > existingTypePri);

                    if (shouldReplace)
                    {
                        // Remove from old reverse dict entry
                        if (_reverseDict.TryGetValue(existing.Item1, out var oldList))
                        {
                            oldList.Remove(ext);
                            if (oldList.Count == 0)
                            {
                                _reverseDict.Remove(existing.Item1);
                            }
                        }

                        // Update to new value
                        _dict[ext] = mimeType;
                        _entryDict[ext] = Tuple.Create(mimeType, source);

                        if (!_reverseDict.TryGetValue(mimeType, out var keyList))
                        {
                            keyList = new List<string>();
                            _reverseDict.Add(mimeType, keyList);
                        }
                        keyList.Add(ext);
#>
        // Dupe for <#= ext #>: using <#= mimeType #> (<#= source ?? "unknown" #>/type:<#= newTypePri #>) over <#= existing.Item1 #> (<#= existing.Item2 ?? "unknown" #>/type:<#= existingTypePri #>)
<#
                    }
                    else
                    {
#>
        // Dupe for <#= ext #>: keeping <#= existing.Item1 #> (<#= existing.Item2 ?? "unknown" #>/type:<#= existingTypePri #>) over <#= mimeType #> (<#= source ?? "unknown" #>/type:<#= newTypePri #>)
<#
                    }
                }
            }
            else
            {
                _dict[ext] = mimeType;
                _entryDict[ext] = Tuple.Create(mimeType, source);

                if (!_reverseDict.TryGetValue(mimeType, out var keyList))
                {
                    keyList = new List<string>();
                    _reverseDict.Add(mimeType, keyList);
                }

                keyList.Add(ext);
            }
        }
#>

        // Generated <#= _reverseDict.Count  #> unique mime type values
        // Generated <#= _dict.Count  #> type key pairs

<#
        // Output constants for each type
        foreach(var kp in _dict)
        {
#>
        ///<summary><#= kp.Key #></summary>
        public const string <#= GetMimeFieldName(kp.Key) #> = "<#= kp.Value #>";
<#
        }
#>
        // List of all available mimetypes, used to build the dictionary
        internal static readonly Lazy<string[]> ALL_MIMETYPES = new Lazy<string[]>(() => new [] {
<#
        // List constant field names
        foreach (var kp in _dict)
        {
#>
            <#= GetMimeFieldName(kp.Key) #>,
<#		
        }
#>
        });


        ///<summary>File extensions</summary>
        public static class FileExtensions
        {
<#	
        // List constant field names
        foreach (var kp in _dict)
        {
#>
            ///<summary><#= kp.Key #></summary>
            public const string <#= !Char.IsLetter(kp.Key[0]) ? "_" : string.Empty #><#= char.ToUpper(kp.Key[0]) + kp.Key.Substring(1).Replace('-', '_') #> = "<#= kp.Key #>";
<#
        }

#>
        }

        // List of all available extensions, used to build the dictionary
        internal static readonly Lazy<string[]> ALL_EXTS = new Lazy<string[]>(() => new [] {
<#
        // List constant field names
        foreach (var kp in _dict)
        {
#>
            FileExtensions.<#= !Char.IsLetter(kp.Key[0]) ? "_" : string.Empty #><#= char.ToUpper(kp.Key[0]) + kp.Key.Substring(1).Replace('-', '_') #>,
<#		
        }
#>
        });


        // Switch-case instead of dictionary since it does the hashing at compile time rather than run time
        internal static string? LookupType(string type)
        {
            switch (type)
            {
<#
                // Output the actual literal C# dictionary
                foreach (var kp in _reverseDict)
                {
                    foreach (var mimeKey in kp.Value)
                    {					
#>
                case FileExtensions.<#= !Char.IsLetter(mimeKey[0]) ? "_" : string.Empty #><#= char.ToUpper(mimeKey[0]) + mimeKey.Substring(1).Replace('-', '_') #>:
<#
                    }
#>
                    return <#= GetMimeFieldName(kp.Value[0]) #>;

<#
                }
#>
                default: 
                    return null;
            }
        }

        // Switch-case instead of dictionary since it does the hashing at compile time rather than run time
        internal static string[]? LookupMimeType(string mimeType)
        {
            switch (mimeType)
            {
<#
                // Output the actual literal C# dictionary
                foreach (var kp in _reverseDict)
                {
                    var first = true;
                    foreach (var mimeKey in kp.Value)
                    {
#>
                <#= first ? "" : "//" #>case <#= GetMimeFieldName(mimeKey) #>:
<#
                        first = false;
                    }
#>                    return new[] {<#= string.Join(", ", kp.Value.Select(x => $"FileExtensions.{(!Char.IsLetter(x[0]) ? "_" : string.Empty)}{Char.ToUpper(x[0])}{x.Substring(1).Replace('-', '_')}")) #>};
<#
                }
#>
                default: 
                    return null;
            }
        }
    }
}
